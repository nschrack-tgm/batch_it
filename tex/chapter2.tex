% Chapter2

\chapter{State of the Art} \label{chapter:stateoftheart}

	% ##################################################################
	% Warum welche Hardware (Kriterien für unsere Nutzung, Umsetzbarkeit
	% ##################################################################
	\section{Hardwareaufbau einer SPS}
	
	Um die im späteren Verlauf aufbauende Hardware genauer beschreiben zu können, muss zu Beginn ein wenig thematisch ausgeholt werden. So hat der Begriff der Steuerung einen undenkbar hohen Stellenwert, welcher ebenso geklärt gehört.\\
	
	Unter einer Prozess - Steuerung versteht man nach der Norm DIN 19226, sowie in Abbildung 2.1 ersichtlich, einen Vorgang, bei dem durch Rückführen gemessener Prozesszustände, verglichen mit von der speicherprogrammierbaren Steuerung formulierten Parametern, Sollwerte zur Beeinflussung des gesamten Prozesses erzeugt werden. Im Gegensatz zu einer Regelung, muss der von einem Sensor ausgelesene Ist-Wert jedoch nicht zwanghaft rückgeführt werden. \\
	
	Der Steuerkreis besteht aus Sensoren, einem Steuerungsrechner, welcher meistens mittels einer SPS realisiert wird, sowie Aktoren. Die Steuerungseinheit selbst ist ein Rechner, mit dem Hauptaufgabenbereich, die programmierten, im Speicher abgelegten Anweisungen zyklisch auszuführen und über einfach anzusprechende Schnittstellen Daten einzulesen oder auszugeben. \cite{mseitz_sps} \\
	
	Der Begriff SPS wird in der Norm DIN EN 61131-1 (IEC 61131-1) wie folgt definiert:\\
	
	\glqq \textit{Ein digital arbeitendes elektronisches System für den Einsatz in industriellen Umgebungen mit einem programmierbaren Speicher zur internen Speicherung der anwenderorientierten Steuerungsanweisungen zur Implementierung spezifischer Funktionen wie z.B. Verknüpfungssteuerung, Ablaufsteuerung, Zeit-, Zähl- und arithmetische Funktionen, um durch digitale oder analoge Eingangs- und Ausgangssignale verschiedene Arten von Maschinen und Prozesse zu steuern. Die Speicherprogrammierbare Steuerung und die zugehörige Peripheriegerät (das SPS- System) sind so konzipiert, dass sie sich leicht in ein industrielles Steuerungssystem integrieren und in allen ihren beabsichtigten Funktionen einsetzen lassen.}\grqq \space \cite{sps_programmierung}\\
 
 	\begin{figure}[h!]
  		\centering
      	\includegraphics[width=1\textwidth]{graphics/stateoftheart/Aufbau_Steuerkreis_Selfmade.png}
  		\caption{Allgemeiner Aufbau eines Steuerkreises \cite{mseitz_sps}}
	\end{figure}	
 
 
 Im Detail gehört zum Aufbau einer SPS eine Stromversorgung, eine Verarbeitungseinheit (CPU), digitale, sowie analoge I/O Anschlüsse, eine Feldbusschnittstelle und das Programmiergerät, wobei es sich dabei heutzutage eigentlich ausschließlich um einen externen Computer handelt. Die Stromversorgung PS (\textbf{P}ower \textbf{S}upply) wandelt gleichzeitig die Netzspannung in eine 24-V-Gleichspannung um, mit der die Elektronik der SPS versorgt wird.\\
	
	Man unterscheidet mittlerweile drei verschiedene Aufbauarten bei SPSen
	
	\begin{enumerate}
  		\item Hardware - SPS
  		\item Slot - SPS
  		\item Soft - SPS
	\end{enumerate}

	\textbf{Hardware - SPS}\\\\
	Der im vorigen Abschnitt beschriebene Aufbau einer SPS bezieht sich auf die klassische Aufbauform einer \textit{Hardware - SPS}. Ihre Komponenten sind als gewöhnliche Einsteckkarten in einem Gehäuse oder Schaltschrank angeordnet und sind über einen Rückwandbus miteinander verbunden. Die Hardware - SPS benötigt einen externen PC als Programmiergerät.\\
	
	\textbf{Slot - SPS}\\\\
	Eine Slot - SPS ist eine Einsteckkarte für den PC, welche alle Module einer SPS enthält. Anstatt einer CPU befindet sich ein Co-Prozessor in ihr, auf dem ein eigenes multitaskingfähiges Betriebssystem läuft. Zusätzlich verfügt sie über einen sogenannten multi-ported RAM (ein geteilter Speicher, der sowohl für SPS, als auch für PC zugreifbar ist).\\
	
	\textbf{Soft - SPS}\\\\
	Zu guter Letzt gibt es die Soft - SPS, welche im Gegensatz zu den anderen Steuerungseinheiten eine reine Softwarelösung ist, die komplett auf der CPU des Host-PCs läuft und auch deren Hardware nutzt. Zur Ankopplung der Sensoren und Aktoren wäre eine Einsteckkarte zur Feldbuskopplung notwendig, die mit einem Prozessor zur Buskommunikation und einem dual-ported Ram ausgestattet ist.\\
	
	Die Vorteile der SPS im PC ergeben sich hauptsächlich dadurch, dass die rasante Entwicklung der PC-Leistungen für SPSen genau dafür genutzt werden kann.\\
	
	Die Informationsverarbeitung in einer SPS verläuft zyklisch. Die Verarbeitungsschritte lassen sich vereinfacht mit dem EVA - Prinzip beschreiben.
	
	\begin{itemize}
		\item \textbf{E}inlesen der Sensordaten
		\item \textbf{V}erarbeiten der Informationen im SPS-Programm
		\item \textbf{A}usgeben der Soll-Werte an die Aktoren
	\end{itemize}
	
	Die CPU fragt anfangs nacheinander alle Eingangskanäle ab und legt anschließend die Daten in den Arbeitsspeicher - es entsteht das sogenannte \glqq Eingangsabbild\grqq. Hierbei handelt es sich jedoch nicht um die aktuellen, sondern um die zum Abtastzeitpunkt ausgelesenen Werte. Die erstellten Programme werden ausschließlich von der CPU jeweils Schritt für Schritt abgearbeitet. Erst nach Abarbeitung \textbf{aller} Programme werden die im Ausgangsabbild abgelegten Sollwerte nacheinander an die Ausgangskanäle übertragen. \cite{mseitz_sps} \\ 
		Kleinere SPS - Hersteller versuchen ihre eigene spezifische Hardware möglichst kompatibel für fremde Software zu produzieren, um mit ihrem Produkt eine möglichst große Zielgruppe anzusprechen. Große Hersteller hingegen möchten ihr System eher geschlossen für den Zugriff mittels fremder Software halten, um die Kundenbindung auf den verschiedensten Ebenen der Automatisierungspyramide zu erhöhen.
	
	\begin{figure}[h!]
  		\centering
    	\includegraphics[width=1\textwidth]{graphics/stateoftheart/Signalverarbeitung_Selfmade.png}
  		\caption{Signalverarbeitung und Arbeitsweise einer SPS \cite{mseitz_sps}}
	\end{figure}
		
	% ##############################################################
	% Programmierung einer SPS - Wie funktioniert das grundsätzlich?
	% ##############################################################
	\section{Programmierung einer SPS}

	In der Automatisierungs- und Regelungstechnik gibt es zum Erfüllen der gegebenen Anforderung mehrere Wege um diese zu lösen. Genauer gesagt handelt es sich hierbei um ganze sechs verschiedene Programmiersprachen, um auf jede möglich auftretende, sowie spezifische Anforderung individuell eingehen zu können. Diese unterteilen sich wiederum in zwei differenzierbare Untergruppen. So gibt es zum einen die textbasierten Programmiersprachen
	
	\begin{itemize}
		\item[a)] Anweisungsliste (engl. \textit{Instruction List})
		\item[b)] Strukturierter Text (engl. \textit{Structured Text})
		\item[c)] Ablaufsprache (engl. \textit{Sequential Function Chart})
	\end{itemize}

	Im Gegensatz dazu gibt es noch die grafikbasierten Programmiersprachen
	
	\begin{itemize}
		\item[d)] Kontaktplan (engl. \textit{Ladder Diagram})
		\item[e)] Ablaufsprache (engl. \textit{Sequential Function Chart})
		\item[f)] Funktionsbausteinsprache (engl. \textit{Function Block Diagram})
	\end{itemize}
	
	Ziel dieser Vielfalt ist es, eine Vereinheitlichung der Programmierung von SPSen zu erreichen. Der Standard 61131 ist seit 1993 eingeführt und industriell etabliert. Mittlerweile schon in der dritten Edition verfügbar, und somit auch Objektorientierung unterstützend, sind die Programmiersprachen für zentrale \& eng gekoppelte Systeme ausgelegt.\\
	
	\textbf{a) Anweisungsliste}\\
	
	Diese textbasierte Programmiersprache nach der Norm IEC DIN EN 61131-3 ist sehr maschinennahe. Vergleicht man die Anweisungsliste aus Abbildung 2.3 mit höheren Programmiersprachen der Informatik, so ist es eine Art Assemblersprache, die normalerweise 1:1 den jeweiligen Maschinencode übersetzt. Es werden die einzelnen Anweisungen in der Reihenfolge geschrieben, wie sie die Maschine (CPU) abarbeiten soll (auch \glqq Stackorientierte Abarbeitung\grqq \space genannt). Ein großer Vorteil gegenüber allen graphischen Programmiersprachen ist die Tatsache, das AWL funktionell über diese hinausgeht, weil beispielsweise ein komplexer Zählvorgang mittels eines Kontaktplans nicht realisierbar sein könnte.	\cite{spslehrgang_struktur, egroetsch_sps}\\

	\begin{figure}[h!]
		\begin{framed}
			VAR\\			s1: BOOL; \color{gray}//[input] Sensor Deklaration\\ \color{black}			s2: BOOL; \color{gray}//[input] Sensor Deklaration\\ \color{black}			s3: BOOL; \color{gray}//[input] Sensor Deklaration\\ \color{black}			M: BOOL := 0; \color{gray}//[output] Motor Deklaration (muss initialisiert werden)\\ \color{black}			END\_VAR\\\\
			LD s1; \color{gray}//[load] Lade den boolean-Wert ins Register\\ \color{black}			OR s2; \color{gray}//Oder-Verknüpfung mit s1\\ \color{black}			ANDN s3; \color{gray}//Und-Verknüpfung mit invertiertem Eingang\\ \color{black}			ST \color{gray}//[store] Ergebnis wird in die Variable Motor geschrieben\\
		\end{framed}
		\caption{Beispiel einer Anweisungsliste}
	\end{figure}
	
	\color{black}
	\textbf{b) Strukturierter Text}\\
	
	Diese in Abbildung 2.4 angeführte Programmiersprache der Automatisierungstechnik orientiert sich an der Sprache Pascal, enthält aber neben dieser Sprache zugehörigen spezifischen Elementen aber auch noch SPS-typische Elemente. Geeignet ist ST am vorteilhaftesten für Aufgaben mit mathematischem Hintergrund, sowie zum Beschreiben komplexer Algorithmen. Auch für Rezept- und Datenverwaltung hebt sich diese Art der Programmierung durch enorme Vereinfachung vor. Typische Anweisungen für ST sind solche, die in höheren Sprachen durch Bedingungen oder Schleifen ausgeführt werden können \cite{grundlagen_automatisierungstechnik}
	\todo[inline]{Schauen ob die Figur \glqq Strukturierter Text\grqq \space an der richtigen Position ist.}
	
	\begin{figure}[h]
		\begin{framed}
		\color{black}
		VAR\\		s1: BOOL; \color{gray}//[input] Sensor Deklaration\\ \color{black}		s2: BOOL; \color{gray}//[input] Sensor Deklaration\\ \color{black}		s3: BOOL; \color{gray}//[input] Sensor Deklaration\\ \color{black}		M: BOOL := 0; \color{gray}//[output] Motor Deklaration ( muss initialisiert werden)\\ \color{black}		END\_VAR\\		M := (s1 OR s2) AND ( NOT (s3)); \color{gray}//ODER-Verknüpfung von s1 und s2, anschließendes UND-Verknüpfung von Ergebnis mit negiertem s3.\
		\end{framed}
		\caption{Beispiel eines strukturierten Textes}
	\end{figure}
	
	\color{black}
	\textbf{c, e) Ablaufsprache}\\
	
	Eine Sonderstellung unter den Sprachen zur Programmierung einer SPS nimmt die Ablaufsprache ein.
	\todo[inline]{Ablaufsprache noch genauer beschreiben!}
	\textbf{d) Kontaktplan}\\
	Die Darstellungsart des Kontaktplans ermöglicht SPS-Programmierern ein Programm auf graphischer Ebene zu erstellen und darzustellen. Ein KOP ist einem Stromlaufplan sehr ähnlich, um Programmieranfängern, die beispielsweise nur in der Elektronik tätig sind/waren und noch nie zuvor analytisch hinterfragten Code entwickelt haben, dein Einstieg zu erleichtern. Es werden Elemente wie Spulen, Öffner/Schließer, Eingänge/Ausgänge, usw... verwendet, die zu logischen Blöcken zusammengefasst werden können und so einen Teil des gesamten Programms ergeben. Ein Nachteil dieser standardisierten Programmiersprache ist jedoch, dass es nicht für alle möglichen Operationen auch ein einheitliches Symbol in einem Stromlaufplan gibt. Das wiederum bedeutet, dass bei komplexen Steuerungen oft eine Mischung aus KOP und der Funktionsbausteinsprache (FBS) verwendet wird.
	\todo[inline]{Schauen ob das Bild \glqq kop\_Selfmade\grqq \space an der richtigen Position ist.}
	\begin{figure}[h!]
  		\centering
    	\includegraphics[width=0.8\textwidth]{graphics/stateoftheart/kop_Selfmade.png}
  		\caption{Beispiel eines Kontaktplans \cite{kontaktplan}}
	\end{figure}

	\newpage
	\textbf{f) Funktionsbausteinsprache}\\

	Diese graphische Programmiersprache verwendet für ihre Anweisungen logische Symbole der Boolschen Algebra. Diese Sprache ist insbesondere für Verknüpfungssteuerungen geeignet und deswegen bei Anfängern oder Programmier - Laien beliebt. Durch den einfachen graphischen Aufbau ist die Programmlogik relativ schnell zu erkennen und nachzuvollziehen.

	\begin{figure}[h!]
  		\centering
    	\includegraphics[width=0.8\textwidth]{graphics/stateoftheart/funktionsbausteinplan_Selfmade.png}
  		\caption{Beispiel eines Funktionsbausteinplans \cite{funktionsbausteinplan}}
	\end{figure}

\section{Phasen und Rezepte}

TODO

\section{Visualisierung von Produktionsanlagen}
Die Visualisierung einer Produktionsanlage ist ein wesentlicher Punkt der Datenverarbeitung und wird oft als Benachrichtigungszentrale benutzt. Meist werden in diesen in Echzeit aktualisierte Statuswerte sowie Benachrichtigungen zu unerwarteten Ereignissen angezeigt. Die hierfür benötigten Daten müssen von der SPS in die Visualisierungssoftware übermittelt werden. Da dies ein sehr aufwendiger Prozess ist, gibt es SCADA-Systeme die all diese Funktionen vereinen.\\
\\
\textbf{SCADA}\\
(Supervisory Control And Data Acquisition)\\
Ein SCADA System ist im Allgemeinen eine Sammelstelle für alle aus der Anlagen generierten Werte. Diese Daten müssen dann weiterverarbeitet werden um aus ihnen Analysen zu erstellen.\\
Zu den Elemente eines SCADA Systems gehören:\\
\\
%todo Quelle Scada
%http://www.engineersgarage.com/articles/scada-systems?page=1
%10 März 2015
\textbf{SCADA Master Station Computer Systems}\\
Sammelstelle für Echtzeitdaten die von RTUs generiert werden. Meist herkömmliche Computer Hardware.\\
\\
\textbf{Human-Machine Interface}\\
Aus den gesammelten Daten Analysen (Prognosen, Diagnosen) so aufbereiten das sie für den Menschen leicht verständlich dargestellt werden.\\
\\
\textbf{Remote Terminal Units (RTUs)}\\
Sensoren die Physikalische Änderungen in der Anlage mit einem Signalumformer in Elektrische Werte umwandelt. Je nachdem was gemessen werden soll, entstehen Analoge (Füllstand, Helligkeit, Druck, ...) oder Digitale (z.B. Status eines Geräts) Werte.\\
\\

%Quelle http://www.protec.at/dienstleistungen/visualisierung
%Quelle http://www.protec.at/tl_files/protec/uploads/Bilder_Logos/Visualisierung/visualisierung2.jpg
\begin{figure}[hbt!]
 \centering
  \includegraphics[width=1\textwidth]{graphics/stateoftheart/zenon_visualisierung}
  \caption{Visualisierung in Zenon Supervisor}
\end{figure}


\newpage
\section{Konzeptioneller Entwurf, Modellbasierte Entwicklung}
Das Gebiet der Modellbasierten Entwicklung bzw. der automatisierten Codegenerierung aus so einem Modell als ganzes kann man nicht wirklich als State of the Art erklären.\\
\\
Wenn man sich jedoch die Gebiete als einzelnes anschaut, erkennt man das diese im heutigem Betrieb eingesetzt werden.
\subsection{Modell}
Ein Modell der gesamten Anlage wird schon im frühen Stadium der Entwicklung in Form eines RI-Fließschemas hergestellt um klar zu definieren welche Bauteile benötigt werden und welches mit welchem Bauteil verbunden ist. Dies ist nur das erste Modell das in der Industrie eingesetzt wird.\\
\\
Oft werden aber mehr Informationen benötigt als im RI-Fließschema ersichtlich sind, weswegen man auf eine andere Methode umsteigen muss ein Modell abzubilden.\\
Auf die gängigsten Methoden (XML, Ontologie, UML) wird in den nächsten Punkten genauer eingegangen.
\subsubsection{XML}
XML ist ein Textbasiertes Dateiformat das, obwohl es für Dokumente gedacht ist, oft für das Abbilden von Daten Strukturen verwendet wird.
\\
Ähnlich wie in HTML verwendet auch XML Tags, der unterschied besteht darin das XML keine vorgefertigten Tags besitzt und der Benutzer diese erstellt. Genau diese Benutzerdefinierten Tags ergeben die XML Struktur welche, was essentiell ist, von alleine nur ein Textfile ist und keine Funktionen besitzt.
\\
\lstinputlisting[language=XML,belowcaptionskip=5pt,caption=XML Sample Code]{extra/sample.xml}
Der Aufbau einer XML Datei ist leicht zu erklären: Es gibt 1 rootElement das den Anfang und das Ende des Inhaltes markiert, zwischen dem Start- und Endtag befinden sich weitere Tags die das Dokument oder die Struktur genauer beschreiben. Jeder Tag kann Attribute besitzen die es weiter definieren. Zwischen einem Start- und Endtag können sich entweder weitere Tags oder einfacher Text befinden.
\\
Einsatz findet XML meist in Programmen oder Webseiten die größere Mengen an Daten bzw. Befehle Systemunabhängig übertragen sollen. Grund dafür ist unter anderem die Tatsache dass Mensch und Maschine die Datei ohne Übersetzung/Kompilieren lesen und verstehen kann.\\
Doch auch wenn ein Mensch XML-Dateien lesen kann, dauert es länger die Struktur eines Textes, im vergleich zu einer Grafischen Darstellung, zu verstehen.\\ 
Dafür gibt es andere Werkzeuge, die auf XML basieren aber eine Grafische Darstellung erzeugen.
\subsubsection{Ontologie}
%todo Quelle Ontologie
%http://plato.stanford.edu/entries/logic-ontology/
\begin{displayquote}... we have at least two parts to the overall philosophical project of ontology: first, say what there is, what exists, what the stuff is reality is made out off, secondly, say what the most general features and relations of these things are.
\end{displayquote}
Eine Ontologie ist ein auf XML basierendes Konstrukt das einem das Abbilden von Dingen und deren Relationen ermöglicht. Um solch Komplexe Zustände darzustellen stehen einem neben einfachen Entitäten(Dinge) auch Eigenschaften zur verfügen.\\
\\
\textbf{Allgemeiner Aufbau einer Ontologie}\\
Das Modell an sich ohne zusätzliche Attribute oder Eigenschaften ist vom Aufbau her so zu erklären: Es gibt ein 'Thing' von dem alles aus geht (das root Element bei XML). Von diesem Punkt aus können weitere Entitäten abgeleitet werden (Eine Vererbung, vergleichbar mit einem Stammbaum). Die neu erstellte Entität ist immer noch ein Thing, jedoch genauer definiert. Es gibt keine Grenzen oder Vorschriften in welche Tiefe diese Definition gehen muss und kann daher für sehr Komplexe aber auch Simple Modelle eingesetzt werden.\\

\begin{figure}[hbt!]
 \centering
  \includegraphics[width=1\textwidth]{graphics/stateoftheart/Ontology_Aufbau}
  \caption{Aufbau einer Ontologie}
\end{figure}

Wie in Abbildung 1 zu erkennen erhält man so die Struktur des Modells, jedoch werden oft weitere Informationen zu den einzelnen Objekten/Entitäten benötigt welche als Eigenschaften abgespeichert werden.\\
Dies ermöglicht ein Modell aufzubauen das nicht nur die Struktur abbilden kann, sondern komplexe Netzwerke zu konstruieren.\\
\\
\noindent \textbf{Objekt Eigenschaften}\\
Objekt Eigenschaften werden benötigt um Relationen zwischen den einzelnen Objekten genauer zu beschreiben.\\ 
Wie kann man einen Tank mit einer Pumpe verbinden? Genau dafür gibt es Objekt Eigenschaften. Für diesen zweck kann man eine Eigenschaft mit dem Namen 'verbunden\_mit' erstellen, und diese dann dem Tank beifügen. So ergibt sich die Relation: Tank verbunden\_mit Pumpe.\\
\\
\textbf{Daten Eigenschaften}\\
Daten Eigenschaften werden benötigt um Objekte genauer zu beschreiben. 
\\
Beispiel für ein Modell einer Produktionsanlage ist es etwaigen Sensoren im Modell einen Wertebereich festzulegen in welchem dieser arbeitet bzw. was für Werte dieser sammelt/zurückgibt: Ein Füllstandsensor mit einem Wertebereich von 4-20V, wobei 4V=Leer und 20V=Voll bedeutet, kann in einer Ontologie mit wenigen Data Properties abgebildet werden.

\subsubsection{UML}
UML ist, wie eine Ontologie, eine auf XML basierte Modellierungssprache.
%TODO Quelle UML
%Quelle OMG Unified Modeling LanguageTM (OMG UML), Infrastructure
Das Ziel von UML ist es, System Architekten, Software Ingenieuren und Software Entwicklern ein Werkzeug zur Analyse, Design, Implementation von Softwarebasierenden Systemen, sowie für Modell Entwicklung und ähnliche Prozesse zu bieten.\\
\\
\textbf{Activity}\\
%TODO Quelle Activity
%Quelle OMG Unified Modeling LanguageTM (OMG UML), Version 2.5An Activity is a kind of Behavior (see sub clause 13.2) that is specified as a graph of nodes interconnected by edges. A subset of the nodes are executable nodes that embody lower-level steps in the overall Activity. Object nodes hold data that is input to and output from executable nodes, and moves across object flow edges. Control nodes specify sequencing of executable nodes via control flow edges. Activities are essentially what are commonly called “control and data flow” models. Such models of computation are inherently concurrent, as any sequencing of activity node execution is modeled explicitly by activity edges, and no ordering is mandated for any computation not explicitly sequenced.\\Activities may describe procedural computation, forming hierarchies of Activities invoking other Activities, or, in an object- oriented model, they may be invoked indirectly as methods bound to Operations that are directly invoked. Activities may be applied to organizational modeling for business process engineering and workflow. In this context, events often originate from inside the system, such as the finishing of a task, but also from outside the system, such as a customer call. Activities can also be used for information system modeling to specify system level processes.\\
Activity Nodes\\ActivityNodes are used to model the individual steps in the behavior specified by an Activity.\\
Activity Edges\\An ActivityEdge is a directed connection between two ActivityNodes along which tokens may flow, from the source ActivityNode to the target ActivityNod.\\
\section{Fazit}

%TODO Codegenerierung
%Sinnvoll in State of the Art?	